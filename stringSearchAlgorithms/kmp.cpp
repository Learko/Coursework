#include <stdexcept>
#include "..\dataStructures\list.h"


/* Префикс функция
 * Принимает строку, возвращает массив чисел - значение префикс ф-ии */
int *prefix(char *str)
{
	int len = strlen(str);    // Длина строки
	int *pref = new int[len]; // Значение префикс функции

	pref[0] = 0; // Первый эл-т равен 0
	for (int i = 1; i < len; i++) // Идем по строке до конца
	{
		int p = pref[i - 1]; // Предыдущее значение префикс функции
		while (p > 0 && str[i] != str[p]) // Пока эл-т строки не совпадает с эл-ом шаблона
			p = pref[p - 1]; // Значение префикс функции (первое совпадение или 0, если начало строки)

		if (str[i] == str[p]) // Если символы равны
			p++; // Увеличиваем значение префикс ф-ии

		pref[i] = p;
	}

	return pref; // Возвращает массив чисел - значение префикс ф-ии
}


/* Алгоритм поиска первого вхождения подстроки в строку Кнута-Морриса-Пратта       *
 * Принимает строку(haystack) и шаблон(needle)                                     *
 * Возвращает список индексов начал всех вхождений                                 */
List *kmp(char *haystack, char *needle)
{
	List *entry = new List(); // Индекс первого вхождения

	int haystackLen = strlen(haystack); // Длина строки
	int needleLen = strlen(needle);     // Длина шаблона

	// Если строка или шаблон пустые
	if (needleLen <= 0 || haystackLen <= 0)
		std::logic_error("Empty string");

	int *pref = prefix(needle); // Значение префикс ф-ии

	int shift = 0; // Сдвиг
	while (shift < haystackLen) // Пока не достигнут конец строки
	{
		int match = 0; // Кол-во совпавших символов
		// Пока эл-т строки совпадает с эл-там шаблона и кол-во совпавших символов меньше длины шаблона
		while (haystack[shift + match] == needle[match] && match < needleLen)
			match++;

		if (match == needleLen) // Если кол-во совпавших символов = длине шаблона
			*entry += shift;     // Подстрока найдена, добавляем индекс в список
		
		if (match > 0) // Если найден хоть один совпадающий символ
			shift += match - pref[match - 1]; // Свдигаемся на кол-во совпавших - значение префикс фукции от пред.
		else
			shift++; // Если нет - сдвигаемся на 1 эл-т
	}


	return entry; // Возвращаем список из всех вхождений
}
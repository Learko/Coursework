#pragma once

/* Быстрая сортировка
 * Принимает указатель на первый эл-т массива, длину массива
 * start - дополнительный параметр, для сортировки подмассивов
 *  (индекс эл-а с к-го нужно начать сортировку) */
void quickSort(int *Arr, int n, in#include "radixsort.h"


/* Поразрядная сортировка
 * Принимает массив - arr и его длину - length */
void radixSort(int *arr, int length)
{
	/* Находим максимальный по модулю эл-т
	 * Если эл-т >= 0 берем его, иначе берем противоположный ему */
	int max = arr[0] >= 0 ? arr[0] : -arr[0];
	for (int i = 1; i < length; i++)
	{
		int tmp = arr[i] >= 0 ? arr[i] : -arr[i];
		if (tmp > max)
			max = tmp;
	}

	// Кол-во значимых бит
	int numOfBits = 0;
	for (; max > 0; max >>= 1, numOfBits++); // Пока число > 0 побитово сдвигаем его на 1 разряд, и увеличиваем счетчик битов

	/* Сортируем массив рассматривая лишь 1 бит                                             *
	 * Перебираем биты от 0 до максимального                                                *
	 * Вызываем ф-ю сортировки передавая в нее:                                             *
	 * Массив, его длину, максимальное значение эл-та(после применения ф-ии) и ф-ию.        *
	 * Ф-ия берет i - номер проверяемого бита и сдвигает эл-т на это кол-во бит вправо,     *
	 * далее применяет логическое "И" с 1, тем самым беря только 1 правый бит,              *
	 * если число при этом было отрицательное, то инвертирует его, и сортирует как обычное. */
	for (int i = 0; i < numOfBits; i++)
		customSort(arr, length, 1, [i](int a) { if (a >= 0) return ((a >> i) & 1); else return ((~a >> i) & 1); });

	/* После сортировки получился отсортированный массив без учета знака                   *
	 * поэтому необходимо перенести все отрицательные эл-ты в начало массива.              *
	 * Создаем список, если эл-т больше 0 записываем его в конец, иначе вставляем в начало */
	List result = List();
	for (int i = 0; i < length; i++)
		if (arr[i] >= 0)
			result.append(arr[i]);
		else
			result.insert(arr[i], 0);

	/* Образовавшийся список нужно перезаписать в исходный массив  *
	 * метод begin возвращает ссылку на первый эл-т списка,        *
	 * благодаря этому мы можем пройти по списку за n              */
	int i = 0;
	for (auto it : result)
		arr[i++] = *it.data;
}t start = 0);

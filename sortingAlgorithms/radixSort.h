#pragma once
#include "..\dataStructures\list.h"


/* Поразрядная сортировка
 * Принимает массив - Arr и его длину - length */
void radixSort(int *arr, int length);


/* Сортировка массива Arr длины length, с максимальным эл-м max (0 <= элемент <= max),                                                     *
 * key - ф-я к-я будет применена к каждому эл-ту на время сортировки, по умолчанию возращает неизмененный эл-т.                            *
 * Функция key принимает одно значение типа int и возращает другое* значение типа int                                                      *
 * Шаблон ф-ии необходим, чтобы в будущем была возможность использовать условя захвата(по умолчанию в кач-ве ключа ф-ии не поддерживаются) */
template <typename Func = int (*)(int)>
void customSort(int *arr, int length, int max, Func key = [](int data)->int { return data; })
{
	List *arrayLists = new List[max + 1]; // Массив списков, 1 список на 1 возможный эл-т
	for (int i = 0; i <= max; i++)
		arrayLists[i] = List();

	// Идем по массиву, и записываем в индекс равный результату ф-ии(по умолчанию возвращается сам эл-т) от эл-та
	for (int i = 0; i < length; i++)
		arrayLists[key(arr[i])] += arr[i];

	/* Полученные списки необходимо соеденить в 1 массив по порядку,              *
	 * для этого идем по всем спискам и переносим эл-т в исходный массив          *
	 * Метод begin возвращает ссылку на 1-й эл-т списка, data - адрес содержимого */
	int i = 0;
	for (int m = 0; m <= max; m++)
		for (auto it : arrayLists[m])
			arr[i++] = *it.data;
}
